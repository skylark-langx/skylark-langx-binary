{"version":3,"sources":["base64.js"],"names":["define","exports","byteLength","b64","lens","getLens","validLen","placeHoldersLen","toByteArray","tmp","i","arr","Arr","curByte","len","revLookup","charCodeAt","fromByteArray","uint8","length","extraBytes","parts","maxChunkLength","len2","push","start","end","output","num","lookup","join","Uint8Array","Array","code","Error","indexOf"],"mappings":";;;;;;;AAAAA,OAAO,GAAG,WACR,aACA,IAAIC,QAAU,CAEdC,WAuCA,SAAqBC,GACnB,IAAIC,EAAOC,EAAQF,CAAG,EAClBG,EAAWF,EAAK,GAChBG,EAAkBH,EAAK,GAC3B,OAAuC,GAA9BE,EAAWC,GAAuB,EAAKA,CAClD,CA9Ce,EAGfN,QAAQO,YAiDR,SAAsBL,GACpB,IAAIM,EAcAC,EAbAN,EAAOC,EAAQF,CAAG,EAClBG,EAAWF,EAAK,GAChBG,EAAkBH,EAAK,GAEvBO,EAAM,IAAIC,EAVhB,SAA2BN,EAAUC,GACnC,OAAuC,GAA9BD,EAAWC,GAAuB,EAAKA,CAClD,EAQqCD,EAAUC,CAAe,CAAC,EAEzDM,EAAU,EAGVC,EAAwB,EAAlBP,EACND,EAAW,EACXA,EAGJ,IAAKI,EAAI,EAAGA,EAAII,EAAKJ,GAAK,EACxBD,EACGM,EAAUZ,EAAIa,WAAWN,CAAC,IAAM,GAChCK,EAAUZ,EAAIa,WAAWN,EAAI,CAAC,IAAM,GACpCK,EAAUZ,EAAIa,WAAWN,EAAI,CAAC,IAAM,EACrCK,EAAUZ,EAAIa,WAAWN,EAAI,CAAC,GAChCC,EAAIE,CAAO,IAAOJ,GAAO,GAAM,IAC/BE,EAAIE,CAAO,IAAOJ,GAAO,EAAK,IAC9BE,EAAIE,CAAO,IAAY,IAANJ,EAGK,IAApBF,IACFE,EACGM,EAAUZ,EAAIa,WAAWN,CAAC,IAAM,EAChCK,EAAUZ,EAAIa,WAAWN,EAAI,CAAC,IAAM,EACvCC,EAAIE,CAAO,IAAY,IAANJ,GAGK,IAApBF,IACFE,EACGM,EAAUZ,EAAIa,WAAWN,CAAC,IAAM,GAChCK,EAAUZ,EAAIa,WAAWN,EAAI,CAAC,IAAM,EACpCK,EAAUZ,EAAIa,WAAWN,EAAI,CAAC,IAAM,EACvCC,EAAIE,CAAO,IAAOJ,GAAO,EAAK,IAC9BE,EAAIE,CAAO,IAAY,IAANJ,GAGnB,OAAOE,CACT,EA5FAV,QAAQgB,cAkHR,SAAwBC,GAQtB,IAPA,IAAIT,EACAK,EAAMI,EAAMC,OACZC,EAAaN,EAAM,EACnBO,EAAQ,GACRC,EAAiB,MAGZZ,EAAI,EAAGa,EAAOT,EAAMM,EAAYV,EAAIa,EAAMb,GAAKY,EACtDD,EAAMG,KAtBV,SAAsBN,EAAOO,EAAOC,GAGlC,IAFA,IAAIjB,EACAkB,EAAS,GACJjB,EAAIe,EAAOf,EAAIgB,EAAKhB,GAAK,EAChCD,GACIS,EAAMR,IAAM,GAAM,WAClBQ,EAAMR,EAAI,IAAM,EAAK,QACP,IAAfQ,EAAMR,EAAI,IACbiB,EAAOH,KAfX,SAA0BI,GACxB,OAAOC,EAAOD,GAAO,GAAK,IACxBC,EAAOD,GAAO,GAAK,IACnBC,EAAOD,GAAO,EAAI,IAClBC,EAAa,GAAND,EACX,EAUgCnB,CAAG,CAAC,EAElC,OAAOkB,EAAOG,KAAK,EAAE,CACvB,EAYMZ,EAAOR,EAA0Ba,EAAtBb,EAAIY,EAAyBC,EAAQb,EAAIY,CACtD,CAAC,EAIgB,GAAfF,GACFX,EAAMS,EAAMJ,EAAM,GAClBO,EAAMG,KACJK,EAAOpB,GAAO,GACdoB,EAAQpB,GAAO,EAAK,IACpB,IACF,GACwB,GAAfW,IACTX,GAAOS,EAAMJ,EAAM,IAAM,GAAKI,EAAMJ,EAAM,GAC1CO,EAAMG,KACJK,EAAOpB,GAAO,IACdoB,EAAQpB,GAAO,EAAK,IACpBoB,EAAQpB,GAAO,EAAK,IACpB,GACF,GAGF,OAAOY,EAAMS,KAAK,EAAE,CACtB,EA5IA,IALA,IAAID,EAAS,GACTd,EAAY,GACZH,EAA4B,aAAtB,OAAOmB,WAA6BA,WAAaC,MAEvDC,EAAO,mEACFvB,EAAI,EAAGI,EAAMmB,EAAKd,OAAQT,EAAII,EAAK,EAAEJ,EAC5CmB,EAAOnB,GAAKuB,EAAKvB,GACjBK,EAAUkB,EAAKjB,WAAWN,CAAC,GAAKA,EAQlC,SAASL,EAASF,GAChB,IAAIW,EAAMX,EAAIgB,OAEd,GAAc,EAAVL,EAAM,EACR,MAAM,IAAIoB,MAAM,gDAAgD,EAK9D5B,EAAWH,EAAIgC,QAAQ,GAAG,EAG1B5B,GAFiBD,EAAJ,CAAC,IAAdA,EAA4BQ,EAEVR,KAAaQ,EAC/B,EACA,EAAKR,EAAW,EAEpB,MAAO,CAACA,EAAUC,EACpB,CAmHA,OAvIAQ,EAAU,IAAIC,WAAW,CAAC,GAAK,GAC/BD,EAAU,IAAIC,WAAW,CAAC,GAAK,GAsIxBf,OACT,CAAC","file":"../base64.js","sourcesContent":["define([],function(){\r\n  'use strict'\r\n  var exports = {};\r\n\r\n  exports.byteLength = byteLength\r\n  exports.toByteArray = toByteArray\r\n  exports.fromByteArray = fromByteArray\r\n\r\n  var lookup = []\r\n  var revLookup = []\r\n  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\r\n\r\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n  for (var i = 0, len = code.length; i < len; ++i) {\r\n    lookup[i] = code[i]\r\n    revLookup[code.charCodeAt(i)] = i\r\n  }\r\n\r\n  // Support decoding URL-safe base64 strings, as Node.js does.\r\n  // See: https://en.wikipedia.org/wiki/Base64#URL_applications\r\n  revLookup['-'.charCodeAt(0)] = 62\r\n  revLookup['_'.charCodeAt(0)] = 63\r\n\r\n  function getLens (b64) {\r\n    var len = b64.length\r\n\r\n    if (len % 4 > 0) {\r\n      throw new Error('Invalid string. Length must be a multiple of 4')\r\n    }\r\n\r\n    // Trim off extra bytes after placeholder bytes are found\r\n    // See: https://github.com/beatgammit/base64-js/issues/42\r\n    var validLen = b64.indexOf('=')\r\n    if (validLen === -1) validLen = len\r\n\r\n    var placeHoldersLen = validLen === len\r\n      ? 0\r\n      : 4 - (validLen % 4)\r\n\r\n    return [validLen, placeHoldersLen]\r\n  }\r\n\r\n  // base64 is 4/3 + up to two characters of the original data\r\n  function byteLength (b64) {\r\n    var lens = getLens(b64)\r\n    var validLen = lens[0]\r\n    var placeHoldersLen = lens[1]\r\n    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\r\n  }\r\n\r\n  function _byteLength (b64, validLen, placeHoldersLen) {\r\n    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\r\n  }\r\n\r\n  function toByteArray (b64) {\r\n    var tmp\r\n    var lens = getLens(b64)\r\n    var validLen = lens[0]\r\n    var placeHoldersLen = lens[1]\r\n\r\n    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\r\n\r\n    var curByte = 0\r\n\r\n    // if there are placeholders, only get up to the last complete 4 chars\r\n    var len = placeHoldersLen > 0\r\n      ? validLen - 4\r\n      : validLen\r\n\r\n    var i\r\n    for (i = 0; i < len; i += 4) {\r\n      tmp =\r\n        (revLookup[b64.charCodeAt(i)] << 18) |\r\n        (revLookup[b64.charCodeAt(i + 1)] << 12) |\r\n        (revLookup[b64.charCodeAt(i + 2)] << 6) |\r\n        revLookup[b64.charCodeAt(i + 3)]\r\n      arr[curByte++] = (tmp >> 16) & 0xFF\r\n      arr[curByte++] = (tmp >> 8) & 0xFF\r\n      arr[curByte++] = tmp & 0xFF\r\n    }\r\n\r\n    if (placeHoldersLen === 2) {\r\n      tmp =\r\n        (revLookup[b64.charCodeAt(i)] << 2) |\r\n        (revLookup[b64.charCodeAt(i + 1)] >> 4)\r\n      arr[curByte++] = tmp & 0xFF\r\n    }\r\n\r\n    if (placeHoldersLen === 1) {\r\n      tmp =\r\n        (revLookup[b64.charCodeAt(i)] << 10) |\r\n        (revLookup[b64.charCodeAt(i + 1)] << 4) |\r\n        (revLookup[b64.charCodeAt(i + 2)] >> 2)\r\n      arr[curByte++] = (tmp >> 8) & 0xFF\r\n      arr[curByte++] = tmp & 0xFF\r\n    }\r\n\r\n    return arr\r\n  }\r\n\r\n  function tripletToBase64 (num) {\r\n    return lookup[num >> 18 & 0x3F] +\r\n      lookup[num >> 12 & 0x3F] +\r\n      lookup[num >> 6 & 0x3F] +\r\n      lookup[num & 0x3F]\r\n  }\r\n\r\n  function encodeChunk (uint8, start, end) {\r\n    var tmp\r\n    var output = []\r\n    for (var i = start; i < end; i += 3) {\r\n      tmp =\r\n        ((uint8[i] << 16) & 0xFF0000) +\r\n        ((uint8[i + 1] << 8) & 0xFF00) +\r\n        (uint8[i + 2] & 0xFF)\r\n      output.push(tripletToBase64(tmp))\r\n    }\r\n    return output.join('')\r\n  }\r\n\r\n  function fromByteArray (uint8) {\r\n    var tmp\r\n    var len = uint8.length\r\n    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\r\n    var parts = []\r\n    var maxChunkLength = 16383 // must be multiple of 3\r\n\r\n    // go through the array every three bytes, we'll deal with trailing stuff later\r\n    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\r\n      parts.push(encodeChunk(\r\n        uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\r\n      ))\r\n    }\r\n\r\n    // pad the end with zeros, but make sure to not forget the extra bytes\r\n    if (extraBytes === 1) {\r\n      tmp = uint8[len - 1]\r\n      parts.push(\r\n        lookup[tmp >> 2] +\r\n        lookup[(tmp << 4) & 0x3F] +\r\n        '=='\r\n      )\r\n    } else if (extraBytes === 2) {\r\n      tmp = (uint8[len - 2] << 8) + uint8[len - 1]\r\n      parts.push(\r\n        lookup[tmp >> 10] +\r\n        lookup[(tmp >> 4) & 0x3F] +\r\n        lookup[(tmp << 2) & 0x3F] +\r\n        '='\r\n      )\r\n    }\r\n\r\n    return parts.join('')\r\n  }\r\n\r\n  return exports;\r\n});"]}