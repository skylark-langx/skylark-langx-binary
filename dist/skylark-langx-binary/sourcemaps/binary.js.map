{"version":3,"sources":["binary.js"],"names":["define","skylark","attach","fromBase64","str","a","b","c","d","encoding","length","arraybuffer","ArrayBuffer","view","Uint8Array","i","j","indexOf","charAt","fromBinaryString","charCodeAt","fromBuffer","buffer","array","readInt8","data","offset","readUint16","readUint32"],"mappings":";;;;;;;AAAAA,OAAO,CACL,oBACA,SAASC,GACV,aA4FA,OAAOA,EAAQC,OAAO,eAAe,CACpCC,WA/DD,SAAoBC,GAQnB,IAPA,IAKIC,EAAGC,EAAGC,EAAGC,EALTC,EAAW,mEACXC,EAASN,EAAIM,OAAS,EAAI,EAC1BC,EAAc,IAAIC,YAAYF,CAAM,EACpCG,EAAO,IAAIC,WAAWH,CAAW,EAI7BI,EAAI,EAAGC,EAAI,EAAGD,EAAIL,EAAQK,GAAK,EAEtCV,EAAII,EAASQ,QAAQb,EAAIc,OAAOF,CAAC,EAAE,CAAC,EACpCV,EAAIG,EAASQ,QAAQb,EAAIc,OAAOF,CAAC,EAAE,CAAC,EACpCT,EAAIE,EAASQ,QAAQb,EAAIc,OAAOF,CAAC,EAAE,CAAC,EACpCR,EAAIC,EAASQ,QAAQb,EAAIc,OAAOF,CAAC,EAAE,CAAC,EAEpCH,EAAKE,GAAMV,GAAK,EAAMC,GAAK,EAClB,KAANC,IAEFM,EAAKE,EAAE,IAAW,GAAJT,IAAW,EAAMC,GAAK,GAE5B,KAANC,IAEFK,EAAKE,EAAE,IAAW,EAAJR,IAAU,EAAKC,GAI/B,OAAOG,CACR,EAqCCQ,iBApFD,SAA0Bf,GAKzB,IAJA,IAAIM,EAASN,EAAIM,OACbC,EAAc,IAAIC,YAAYF,CAAM,EACpCG,EAAO,IAAIC,WAAWH,CAAW,EAE7BI,EAAI,EAAGA,EAAIL,EAAQK,CAAC,GAE3BF,EAAKE,GAAKX,EAAIgB,WAAWL,CAAC,EAG3B,OAAOJ,CACR,EA0ECU,WA7BD,SAAoBC,GAInB,IAHA,IAAIC,EAAQ,IAAIX,YAAYU,EAAOZ,MAAM,EACrCG,EAAO,IAAIC,WAAWS,CAAK,EAEvBR,EAAI,EAAGA,EAAIO,EAAOZ,OAAQK,CAAC,GAElCF,EAAKE,GAAKO,EAAOP,GAGlB,OAAOQ,CAIR,EAiBCC,SAfE,SAAkBC,EAAMC,GACpB,OAAOD,EAAKC,IAAW,IAAM,EACjC,EAcFC,WAbE,SAAoBF,EAAMC,GACtB,OAAOD,EAAKC,IAAW,EAAID,EAAKC,EAAS,EAC7C,EAYFE,WAXE,SAAoBH,EAAMC,GACtB,OAAQD,EAAKC,IAAW,GAAKD,EAAKC,EAAS,IAAM,GAAKD,EAAKC,EAAS,IAAM,EAAID,EAAKC,EAAS,MAAQ,CACxG,CAUH,CAAC,CACF,CAAC","file":"../binary.js","sourcesContent":["define([\r\n  \"skylark-langx-ns\",\r\n],function(skylark){\r\n\t\"use strict\";\r\n\r\n\r\n\t/**\r\n\t * Create arraybuffer from binary string\r\n\t *\r\n\t * @method fromBinaryString\r\n\t * @param {String} str\r\n\t * @return {Arraybuffer} data\r\n\t */\r\n\tfunction fromBinaryString(str) {\r\n\t\tvar length = str.length;\r\n\t\tvar arraybuffer = new ArrayBuffer(length);\r\n\t\tvar view = new Uint8Array(arraybuffer);\r\n\r\n\t\tfor(var i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tview[i] = str.charCodeAt(i);\r\n\t\t}\r\n\r\n\t\treturn arraybuffer;\r\n\t}\r\n\r\n\t/**\r\n\t * Create arraybuffer from base64 string\r\n\t *\r\n\t * @method fromBase64\r\n\t * @param {String} base64\r\n\t * @return {Arraybuffer} data\r\n\t */\r\n\tfunction fromBase64(str){\r\n\t\tvar encoding = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\t\tvar length = str.length / 4 * 3;\r\n\t\tvar arraybuffer = new ArrayBuffer(length);\r\n\t\tvar view = new Uint8Array(arraybuffer);\r\n\r\n\t\tvar a, b, c, d;\r\n\r\n\t\tfor(var i = 0, j = 0; i < length; i += 3)\r\n\t\t{\r\n\t\t\ta = encoding.indexOf(str.charAt(j++));\r\n\t\t\tb = encoding.indexOf(str.charAt(j++));\r\n\t\t\tc = encoding.indexOf(str.charAt(j++));\r\n\t\t\td = encoding.indexOf(str.charAt(j++));\r\n\r\n\t\t\tview[i] = (a << 2) | (b >> 4);\r\n\t\t\tif(c !== 64)\r\n\t\t\t{\r\n\t\t\t\tview[i+1] = ((b & 15) << 4) | (c >> 2);\r\n\t\t\t}\r\n\t\t\tif(d !== 64)\r\n\t\t\t{\r\n\t\t\t\tview[i+2] = ((c & 3) << 6) | d;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn arraybuffer;\r\n\t}\r\n\r\n\t/**\r\n\t * Create arraybuffer from Nodejs buffer\r\n\t *\r\n\t * @method fromBuffer\r\n\t * @param {Buffer} buffer\r\n\t * @return {Arraybuffer} data\r\n\t */\r\n\tfunction fromBuffer(buffer)\t{\r\n\t\tvar array = new ArrayBuffer(buffer.length);\r\n\t\tvar view = new Uint8Array(array);\r\n\r\n\t\tfor(var i = 0; i < buffer.length; i++)\r\n\t\t{\r\n\t\t\tview[i] = buffer[i];\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t\t//Faster but the results is failing the \"instanceof ArrayBuffer\" test\r\n\t\t//return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\r\n\t}\r\n\r\n    function readInt8(data, offset) {\r\n        return data[offset] << 24 >> 24;\r\n    }\r\n    function readUint16(data, offset) {\r\n        return data[offset] << 8 | data[offset + 1];\r\n    }\r\n    function readUint32(data, offset) {\r\n        return (data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]) >>> 0;\r\n    }\r\n\r\n\r\n\treturn skylark.attach(\"langx.binary\",{\r\n\t\tfromBase64,\r\n\t\tfromBinaryString,\r\n\t\tfromBuffer,\r\n\t\treadInt8,\r\n\t\treadUint16,\r\n\t\treadUint32\r\n\t});\r\n});"]}